# В одномерном массиве найти сумму элементов, находящихся между минимальным и максимальным элементами.
# Сами минимальный и максимальный элементы в сумму не включать

import sys
import random

SIZE = 100
array = [random.randint(0, SIZE) for _ in range(50)]
reg_1 = SIZE #сюда записываем минимальное число, изначально берем SIZE как максимальное число диапазона
reg_2 = 0 #позиция текущего минимального числа
reg_3 = 0 #максимальное число
reg_4 = 0 #позиция текущего максимального числа
count = 0 #наш счетчик
d = 0 #здесь мы будем складывать
for i in array: #счет максимального и минимального чисел
    if i > reg_3:
        reg_3 = i
        reg_4 = count
    if i < reg_1:
        reg_1 = i
        reg_2 = count
    count += 1

if reg_2 > reg_4: #проверка позиций чисел
    ab = array[reg_4+1:reg_2] #создаем список для суммирования
else:
    ab = array[reg_2+1:reg_4]
for f in ab:
    d = d + f
    
print("В используемом диапазоне:", array, "\nМинимальное число ", reg_1, "находится на месте ", reg_2-1)
print("Максимальное число ", reg_3, "находится на месте ", reg_4)
print("Сумма между минимальным и максимальным элементами массива равна : ", d)

print(id(SIZE), id(array), id(reg_1), id(reg_2), id(reg_3), id(reg_4), id(count), id(d), id(ab))

#В функции использованы:
#1 глобальная переменная
#4 переменные, в которые записываются числа получаемые в ходе расчетов
#1 массив array, с которым мы работаем
#1 переменная счетчик
#1 переменная в которой складываем все числа диапазона между двумя искомыми и она является результирующей
#В рамках задания, наша цель выяснить сколько раз встречаются ссылки на объекты, как много было выделено памяти и сравнить с аналогичным вариантом

SIZED = 10
arrayd = [random.randint(0, SIZED * SIZED) for _ in range(SIZED)]
print(arrayd)

idx_min = 0
idx_max = 0
for i in range(1, len(arrayd)):
    if arrayd[i] < arrayd[idx_min]:
        idx_min = i
    elif arrayd[i] > arrayd[idx_max]:
        idx_max = i

if idx_min > idx_max:
    idx_min, idx_max = idx_max, idx_min

print(f'Левая граница: {arrayd[idx_min]}\nПравая граница: {arrayd[idx_max]}')

summ = 0
for i in range(idx_min + 1, idx_max):
    summ += arrayd[i]
print(f'Сумма = {summ}')

#Во втором варианте кода была использована
#1 глобальная переменная
#1 массив данных
#2 переменных для границ диапазона
#1 переменная суммы, которая и является результирующей

print(SIZED, arrayd, idx_min, idx_max, summ)

#Для решения было предложено использовать функцию, которая выводит результат следующего действа:
#напечатать тип переменной, занимаемое ей место и сам анализируемый объект.
#Если функция итерируемая, то если она так же имеет items т.е. является словарем, печатать для каждого ключа и значения в словаре
#те же самые данные, что и для первичной функции и описать уровень вложенности. Иначе если тип данных не строка, то для объектов в x
#показать объекты и добавить доп.вложенность.
#Немного её видоизменим. Вложенные объекты, как таковые отсутствуют в типах данных float, int и str, но при этом существуют в 
#списках, кортежах и в словарях, но там уже в виде ключа и значения, поэтому сперва проверяем, не список ли это или кортеж,
#после - отдельная проверка и вывод для словарей, а при получении остальных типов выводится сообщение, что итоговая функция не
#имеет вложенных элементов и является "конечной"

def callabled(x, level=0):
    print('\t' * level, f'type={type(x)}, Размер={sys.getsizeof(x)}, object={x}, количество ссылок = {sys.getrefcount(x)}')
    if isinstance(x, (list, tuple)):
        _ = 0
        while _ < len(x):
            callabled(x[_], level+1)
            _ += 1
    elif isinstance(x, (dict)):
        for key, value in x.items():
            callabled(key, level + 1)
            callabled(value, level + 1)
    else:
        print("Функция", x ,'не имеет вложенных элементов')
				
#Теперь с помощью данной функции проверим все используемые переменные в обоих вариантах:

print("\nРезультаты сравнения переменных", "\n")
print("Сравниваем глобальные переменные")
print(callabled(SIZE), "\n", callabled(SIZED), "\n")
print("Сравниваем минимальные значения")
print(callabled(reg_1), "\n", callabled(idx_min), "\n")
print("Сравниваем максимальные значения")
print(callabled(reg_3), "\n", callabled(idx_max), "\n")
print("В первом варианте так же использовались две переменные для хранения места")
print(callabled(reg_2), "\n", callabled(reg_4), "\n")
print("Оба варианта предполагали массивы ")
print(callabled(array), "\n", callabled(arrayd), "\n")
print("В первом варианте так же создавался временный список значений")
print(callabled(ab), "\n")
print("И применялась переменная-счетчик")
print(callabled(count), "\n")
print("Ну и итогом всех вычислений было две переменных-результата суммы: ")
print(callabled(d), "\n", callabled(summ), "\n")

from platform import python_version
print("Используемая вами версия pyhton - ", python_version())
#показало 3.6.5
#используемая OS Windows 8.0 64bit
#если проверять командой print (sys.version), то результат ниже
#3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)]
#В обоих вариантах решения использовались одинаковые типы данных, но разные размеры массивов
#Однако второй вариант выигрывает за счет того, что переменных применялось меньше, чем в первом
#В качестве разделителя была использована строка из id всех переменных первого варианта выполнения работы
