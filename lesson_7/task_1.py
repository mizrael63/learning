#Задается массив и функция пузырькового метода
#Пока итерируемый объект меньше длины массива. Для каждого объекта в диапазоне от 0 до максимального значения длины
#Выполняется сравнение со следующим элементом в массиве и в зависимости от условия больший или меньший элемент
#продвигается дальше
#Я добавил скоращение длины на i т.е. на 0, 1, 2... поскольку после прохождения каждого цикла в конце уже получается
#некое наибольшее\наименьшее значение, которое можно исключить из цикла сравнений
#Из идей как заставить его понять что два числа уже между собой отсортированы была только идея с доп.ветвлением:
#Т.е. если некое n и следующее после него число уже стоят по порядку, то если n не нулевое, добавлять в сравнение
#n - 1, а если нулевое, то n+2. Минус однако в том, что таким способом некоторые числа могут оказаться не там
#и сортировка лишь удлиннится, но это все идеи, которые у меня были касательно оптимизации, без превращения
#в другую сортировку
import random
array = [random.randint(-101, 100) for _ in range(15)]


def buble_meth(array):


    i = 0
    print("Исходный массив: ", array)
    while i <= len(array):
        for n in range(len(array)-1-i):
            if array[n] < array[n+1]:
                array[n], array[n + 1] = array[n + 1], array[n]

        print(array)
        i += 1
buble_meth(array)
print("Отсортированный массив: ", array)